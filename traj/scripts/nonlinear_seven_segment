import functools
import time

import numpy as np
import scipy.optimize


def pos_tri_neg_tri_error(x, P, V, P_trgt, V_trgt, J_max):
    delta = x[0:4]
    xi = x[4:8]
    nu = x[8:12]
    a_peak = [J_max * delta[0], -J_max * delta[3]]
    return [
        delta[0] - delta[1],
        delta[3] - delta[2],
        V_trgt - V - (nu[0] + nu[1] + nu[2] + nu[3]),
        0.5 * delta[0] * a_peak[0] - nu[0],
        0.5 * delta[1] * a_peak[0] - nu[1],
        0.5 * delta[2] * a_peak[1] - nu[2],
        0.5 * delta[3] * a_peak[1] - nu[3],
        P_trgt - P - (xi[0] + xi[1] + xi[2] + xi[3]),
        V * delta[0] + 1. / 6. * J_max * delta[0] ** 3 - xi[0],
        (V + nu[0]) * delta[1] + 0.5 * a_peak[0] * delta[1] ** 2 - 1. / 6. ** J_max * delta[1] ** 3 - xi[1],
        (V + nu[0] + nu[1]) * delta[2] - 1. / 6. * J_max * delta[2] ** 3 - xi[2],
        (V_trgt - nu[3]) * delta[3] + 0.5 * a_peak[1] * delta[3] ** 2 + 1. / 6. * J_max * delta[3] ** 3 - xi[3]
    ]


def integrate_segments(P, V, delta_arr, J_max):
    # For now only handling cases with start and end accelerations of zero.
    assert delta_arr[0] == delta_arr[1]
    assert delta_arr[2] == delta_arr[3]
    position_arr = np.zeros(len(delta_arr) + 1)
    position_arr[0] = P
    velocity_arr = np.zeros(len(delta_arr) + 1)
    velocity_arr[0] = V
    acceleration_arr = np.zeros(len(delta_arr) + 1)
    acceleration_arr[0] = 0.0
    jerk_arr = np.array([J_max, -J_max, -J_max, J_max])
    for segment_i, delta in enumerate(delta_arr):
        position_arr[segment_i + 1] = (position_arr[segment_i]
                                       + velocity_arr[segment_i] * delta
                                       + 0.5 * acceleration_arr[segment_i] * delta ** 2
                                       + 1. / 6. * jerk_arr[segment_i] * delta ** 3)
        velocity_arr[segment_i + 1] = (velocity_arr[segment_i]
                                       + acceleration_arr[segment_i] * delta
                                       + 0.5 * jerk_arr[segment_i] * delta ** 2)
        acceleration_arr[segment_i + 1] = acceleration_arr[segment_i] + jerk_arr[segment_i] * delta
    return (position_arr[-1],
            velocity_arr[-1],
            position_arr[1:] - position_arr[:-1],
            velocity_arr[1:] - velocity_arr[:-1])


def pack_optimization_variables(delta_arr, xi_arr, nu_arr):
    return np.hstack((delta_arr, xi_arr, nu_arr))


def test_trajectory(P, V, J_max, delta_arr):
    P_trgt, V_trgt, xi_arr, nu_arr = integrate_segments(P, V, deltas, J_max)
    print(f'Testing P={P}, V={V}, J_max={J_max}, deltas={deltas} P_trgt={P_trgt}, V_trgt={V_trgt}')
    error_function = functools.partial(pos_tri_neg_tri_error, P=P, V=V, P_trgt=P_trgt, V_trgt=V_trgt, J_max=J_max)
    x_ground_truth = pack_optimization_variables(delta_arr, xi_arr, nu_arr)
    x_guess = np.random.random(len(x_ground_truth))
    t_start = time.time()
    optimization_result = scipy.optimize.root(error_function, x_guess, method='hybr')
    t_end = time.time()
    print('Optimization took {} uS'.format((t_end - t_start) * 1e6))
    print(x_ground_truth)
    print(optimization_result.x)


P = 0.0
V = 0.0
J_max = 1.0
deltas = [1.0, 1.0, 1.0, 1.0]
test_trajectory(P, V, J_max, deltas)
