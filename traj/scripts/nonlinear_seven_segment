import functools
import time

import numpy as np
import scipy.optimize


def pos_tri_neg_tri_error(delta_arr, P, V, P_trgt, V_trgt, jerk_arr):
    position_arr, velocity_arr, acceleration_arr = integrate_segments(P, V, delta_arr, jerk_arr)
    return [
        (P_trgt - P) - position_arr[-1],
        (V_trgt - V) - velocity_arr[-1],
        0.0 - acceleration_arr[-1]]


def integrate_segments(P, V, delta_arr, jerk_arr):
    # For now only handling cases with start and end accelerations of zero.
    position_arr = np.zeros(len(delta_arr) + 1)
    position_arr[0] = P
    velocity_arr = np.zeros(len(delta_arr) + 1)
    velocity_arr[0] = V
    acceleration_arr = np.zeros(len(delta_arr) + 1)
    acceleration_arr[0] = 0.0
    for segment_i, delta in enumerate(delta_arr):
        position_arr[segment_i + 1] = (position_arr[segment_i]
                                       + velocity_arr[segment_i] * delta
                                       + 0.5 * acceleration_arr[segment_i] * delta ** 2
                                       + 1. / 6. * jerk_arr[segment_i] * delta ** 3)
        velocity_arr[segment_i + 1] = (velocity_arr[segment_i]
                                       + acceleration_arr[segment_i] * delta
                                       + 0.5 * jerk_arr[segment_i] * delta ** 2)
        acceleration_arr[segment_i + 1] = acceleration_arr[segment_i] + jerk_arr[segment_i] * delta
    return position_arr, velocity_arr, acceleration_arr

def pack_optimization_variables(delta_arr, xi_arr, nu_arr):
    return np.hstack((delta_arr, xi_arr, nu_arr))


def test_trajectory(P, V, delta_arr, jerk_arr):
    position_arr, velocity_arr, acceleration_arr = integrate_segments(P, V, delta_arr, jerk_arr)
    print(f'Testing P={P}, V={V}, jerks={jerk_arr}, deltas={delta_arr}')
    error_function = functools.partial(pos_tri_neg_tri_error, P=P, V=V, P_trgt=position_arr[-1],
                                       V_trgt=velocity_arr[-1], jerk_arr=jerk_arr)
    x_ground_truth = delta_arr
    x_guess = np.random.random(len(x_ground_truth))
    t_start = time.time()
    optimization_result = scipy.optimize.root(error_function, x_guess, method='hybr')
    t_end = time.time()
    print(x_ground_truth)
    print(optimization_result.x)
    print('Optimization took {} uS and ran {} function evaluations'.format(
        (t_end - t_start) * 1e6, optimization_result.nfev))


P = 0.0
V = 0.0
J_max = 1.0
jerk_arr = np.array([J_max, -J_max, J_max])
delta_arr = np.array([1.0, 2.0, 1.0])
test_trajectory(P, V, delta_arr, jerk_arr)
